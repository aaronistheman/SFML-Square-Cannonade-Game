Current:
--------

-generate graph based on locations of walls
	-see #2; (alternate between #1 and #2, as appropriate)
		-1) set up tests for generated graph
			-certain weights of edges
				-how do I access an edge?
					-access some vertex, then check a diagonal incident edge
					and a non-diagonal incident edge
				-diagonal: 14?
				-non-diagonal: 10?
		-2) implement PathfindingGraph constructor in order to pass the test
			-"make edges" (i.e. update vertex data),
			updating the count of edges returned by getNumEdges()
				-implement PathfindingGraph::createEdges() to align
				with the pseudocode and pass the five currently failing tests

	-remove tests and method related to accessing vertex by indices
	-isn't a Tile necessarily a square? So I just need one length parameter
	for constructor??
	-remove C style casts (e.g. in World.cpp)
	(-for the subgoals below, it may help to have some function to translate
	positional coordinates into indices of corresponding vertices in graph)
	-have way to set up goal vertices
	-have way to set start vertex and "run the algorithm"
	(just print a junk statement for now)
	-set up good tile map for World?
-use A* pathfinding algorithm to have enemies avoid walls as
they navigate to the player
	-cite helpful sources
	-unit tests for:
		-making of the grid graph
		-accuracy of algorithm
	-can Boost help?
	-figure out how to make graph
		-map player to the grid it's closest to
	-figure out heuristic function
		-ideas:
			-use distance from player
				-perhaps horizontal distance (to avoid temporal
				cost in using Pythagoren theorem)
	-make sure enemy doesn't freeze if too close to player
	while in its grid square:
		-if enemy and player are in same grid square, set
		the enemy after the player's position (i.e. apply
		waypoint-based AI)
	-don't run A* each frame; maybe do each half second
	-ideas on how:
		-see memo in my phone
		
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-walls (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and wall
		-player and enemy
		-player and coin
	-to prevent anyone going through walls:
		-steps in World.update():
			-set velocities of each entity
			-resolve collisions
				-for an entity that collides with a wall
					-if a component of velocity would cause the entity
					to go through the wall, make that component zero
			-apply velocities (i.e. move the entities)
-victory
-game over
-multiple levels

Eventually:
-----------

-put for-each loop in World::draw()
-why is the TextureHolder passed to the World class?
-remove unused/stub files; e.g.:
	-DrawableTile
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins
-tiles of different terrains
	-in pathfinding graph, apply the costs to the vertices
-test the readme steps for running project/tests
-see if Visual Studio can check for memory leaks
-if collision detection is too slow:
	-join together tiles of similar types to create bigger (rectangular)
	hitboxes:
		-somewhere, enforce that a tileset must be rectangular
			-how to make adding to a TileSet easier?
				-have a "capture" method that checks for rectangular-ness
				after adding all the captured tiles
		-somewhere, enforce that a tile can only be in one set (so walls
		can't be on top of each other)?
		-Wall class (that inherits from TileSet)
-where information on size is known, turn some vectors into arrays
-eliminate unneeded inclusions of <iostream>

Considerable:
-------------

-tile map creator
-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid walls
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system
-on background scolling:
	-instead, make the background switch between scrolling left, up, right,
	and down (based on how far it scrolls out) rather than following player

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square