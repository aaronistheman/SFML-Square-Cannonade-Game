Current:
--------

-implement collision detection (just for the player and walls)
	-collision detection
		-if player intersects a wall, prevent him from moving further into it
			-be able to detect which movement of the player to prevent,
			and prevent it
				-stop left movement if appropriate
				-stop right movement if appropriate
				-stop up if...
				-stop down if...
	-possible safeguards
		-when updating tile map from wall data, check:
			-no collision between wall and any entity (i.e. coin/player start)
	-after implementation
		-this will resolve the bug of there sometimes being no search end
		points, which occurs when the player is in walls, since walls
		don't have corresponding graph vertices
		-if player can't fit easily between two walls, decrease player's size
		(also perhaps consider this for enemies too)
-before dealing with A*, tidy up the class structure, based on notes way below

-can I eliminate wall tiles? They seem to serve no purpose
	-would have to switch to drawing walls by using the Wall class, rather
	than the WallTile class

-speed up my A* algorithm implementation
	-find some way to measure the speed of the algorithm?
		-use an SFML timing class
	-things to speed up:
		-determination of the index to return when the goal vertex is reached
			-instead of storing pointers to the vertices in those four
			vectors, store their indices
				-would have to adjust the tests, which should be easy
		-checking if a neighbor is in the closed or open sets
			-change the sets into arrays that have the vertices' indices
			as array indices (reduces checking speed to O(1))
			-remove the two for loops checking these things
		-determination of which edge cost (10 or 14) to use
		(i.e. determination of whether the neighbor is diagonal or not)
			-remote the two for loops checking these things
		-perhaps initialize any used vectors with space up front, so
		vectors won't resize as often
		-find a way to avoid using getIndex(), since it's slow
			-perhaps have each PGVertex know its index
		-some of the data assignments in my A* implementation may be
		unnecessary, since I end up assigning to the vertex's data when
		it's resolved anyway. More specifically, I don't think there's any
		reason to update the data of the *not yet resolved* neighbors.
		-etc. (look for some things)
-speed up graph creation
	-find some way to measure the speed of the graph creation
		-use an SFML timing class
	-could also put up some load screen to show the user
-speed up my application of the A* algorithm to the World class
	-think of things

-properly pick the next tasks from the below (including the "Eventually"
section)
-straighten out how I want to go about the waypoint system (more specifically,
does the World class set it? or the Hunter class?)
	-each enemy should update its own waypoint in its update() method?
		-but then each enemy would need access to the graph, which
		is fine
-use OOP/inheritance better; Hunter.hpp and Player.hpp have duplication;
Entity could have mSprite and getLength(), perhaps
-review class hierarchy based on notes
-somewhere, enforce that an enemy can't be bigger than a tile
-what to do for enemy's AI if enemy touches player?
	-should a new path for the enemy be found?
-use Visual Studio project filters and folder organization
to make the project more organized
	-e.g. folder for Enemies, because it took me a while to see that Hunters
	had currently been the only enemy
-deal with compiler warnings

-set up good tile map for World?
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-walls (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and wall
		-player and enemy
		-player and coin
	-to prevent anyone going through walls:
		-steps in World.update():
			-set velocities of each entity
			-resolve collisions
				-for an entity that collides with a wall
					-if a component of velocity would cause the entity
					to go through the wall, make that component zero
			-apply velocities (i.e. move the entities)
-victory
-game over
-multiple levels

Eventually:
-----------

-finalize the A* settings (e.g. target tolerance)
	-perhaps move them to their own file
-put for-each loop in World::draw()
-why is the TextureHolder passed to the World class?
-remove unused/stub files; e.g.:
	-DrawableTile
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins
-tiles of different terrains
	-in pathfinding graph, apply the costs to the vertices
-test the readme steps for running project/tests
-see if Visual Studio can check for memory leaks
-if collision detection is too slow:
	-join together tiles of similar types to create bigger (rectangular)
	hitboxes:
		-somewhere, enforce that a tileset must be rectangular
			-how to make adding to a TileSet easier?
				-have a "capture" method that checks for rectangular-ness
				after adding all the captured tiles
		-somewhere, enforce that a tile can only be in one set (so walls
		can't be on top of each other)?
		-Wall class (that inherits from TileSet)
-where information on size is known, turn some vectors into arrays
-eliminate unneeded inclusions of <iostream>
-drop all Git stashes

Considerable:
-------------

-tile map creator
-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid walls
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system
-on background scolling:
	-instead, make the background switch between scrolling left, up, right,
	and down (based on how far it scrolls out) rather than following player
-edit the tests to separate the setup out of the cases, for reusability

List of Regrets (to be put in this project's webpage entry on my
personal website):
---------------------------------------

-not having a strict, consistent, determined order for public methods,
public static variables,
private methods, private member variables, and private static variables
-some test sets might've taken more time to write than they were worth
(e.g. setting start and end vertices)

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square