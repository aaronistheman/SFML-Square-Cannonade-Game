Current:
--------

-getting A* to work (passing the tests)
	(
		-GENERAL NOTES:
			-don't worry too much about speed yet; first, get something working
				-Thus, pick the next vertex in the set of open vertices by
				looking at the entire set. Change this to use a heap later.
			-DO something; don't hesitate too much
	)
	-implement performAStartSearch()
	-tests
		-test for:
			-algorithm's solution (using inputs with deterministic outputs)
			(tests generatePath())
	-set up algorithm
		-have way to set start vertex (given an enemy's position)
		and "run the algorithm"
		(just print a junk statement for now)
			-setting start vertices should just mean putting them in
			the priority queue
		-have way to set up goal vertices (given player's position)
			-setting goal vertices should just mean having them noted,
			such that they are checked when determining whether to terminate
			the algorithm
		-for now, could set heuristic function to zero
	-implement algorithm to pass the tests
		-if a path isn't found, raise an assertion; document that a suitable
		path must exist as a prerequisite for the method
		-translate Wikipedia pseudocode
		-have set of instances of "VertexData" (not necessarily with that name)
		-perhaps borrow Weiss' BinaryHeap class
	-cite helpful sources
-somewhere, enforce that an enemy can't be bigger than a tile
-implementing A*: apply to game
	-perhaps store tile grid in PathfindingGraph instance
	-figure out heuristic function
		-ideas:
			-pure distance (i.e. Pythagorean theorem)
			-perhaps horizontal distance (to avoid temporal
			cost in using Pythagoren theorem)
	-CONCERN: make sure enemy doesn't keep going back and forth across the
	tile it's supposed to be headed to, due to the game's not knowing the
	enemy officially "reached" the tile (may need some epsilon value)
	-CONCERN: make sure enemy doesn't freeze if too close to player
	while in its grid square:
		-if enemy and player are in same grid square, set
		the enemy after the player's position (i.e. apply
		waypoint-based AI)
	-don't run A* each frame; maybe do each half second
		
-set up good tile map for World?
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-walls (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and wall
		-player and enemy
		-player and coin
	-to prevent anyone going through walls:
		-steps in World.update():
			-set velocities of each entity
			-resolve collisions
				-for an entity that collides with a wall
					-if a component of velocity would cause the entity
					to go through the wall, make that component zero
			-apply velocities (i.e. move the entities)
-victory
-game over
-multiple levels

Eventually:
-----------

-put for-each loop in World::draw()
-why is the TextureHolder passed to the World class?
-remove unused/stub files; e.g.:
	-DrawableTile
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins
-tiles of different terrains
	-in pathfinding graph, apply the costs to the vertices
-test the readme steps for running project/tests
-see if Visual Studio can check for memory leaks
-if collision detection is too slow:
	-join together tiles of similar types to create bigger (rectangular)
	hitboxes:
		-somewhere, enforce that a tileset must be rectangular
			-how to make adding to a TileSet easier?
				-have a "capture" method that checks for rectangular-ness
				after adding all the captured tiles
		-somewhere, enforce that a tile can only be in one set (so walls
		can't be on top of each other)?
		-Wall class (that inherits from TileSet)
-where information on size is known, turn some vectors into arrays
-eliminate unneeded inclusions of <iostream>

Considerable:
-------------

-tile map creator
-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid walls
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system
-on background scolling:
	-instead, make the background switch between scrolling left, up, right,
	and down (based on how far it scrolls out) rather than following player
-edit the tests to separate the setup out of the cases, for reusability

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square