Current:
--------

-improving pathfinding
	-waypoint from the path must be set to a center position
	-with two enemies, A* algorithm terminates on exception because all
	vertices end up resolved but the goal somehow isn't reached
		-***THIS: perhaps make at least one unit test involving sending multiple
		enemies to a target, and check correctness of each path (allows
		me to use a small, more easily debuggable world)
	-if enemy reaches the targeted point of his path, he should be set
	to target the next point; reset the currently targeted point when the
	path is reset; this change may make it more permissable to run
	the pathfinding algorithm less often
		-implementing
			-make sure enemy doesn't keep going back and forth across the
			tile it's supposed to be headed to, due to the game's not knowing the
			enemy officially "reached" the tile (may need some epsilon value)
		-also, this change would mean the enemies should initially be set
		to the first coordinate on their respective paths
	-determine why the program ends up crashing from a "run out of memory" error
		-is there a memory leak in my A* implementation?
	-implement walls and collision detection

-speed up graph creation
	-find some way to measure the speed of the graph creation
	-could also put up some load screen to show the user
-speed up my A* algorithm implementation
	-find some way to measure the speed of the algorithm
	-things to speed up:
		-determination of the index to return when the goal vertex is reached
			-instead of storing pointers to the vertices in those four
			vectors, store their indices
				-would have to adjust the tests, which should be easy
		-checking if a neighbor is in the closed or open sets
			-change the sets into arrays that have the vertices' indices
			as array indices (reduces checking speed to O(1))
			-remove the two for loops checking these things
		-determination of which edge cost (10 or 14) to use
		(i.e. determination of whether the neighbor is diagonal or not)
			-remote the two for loops checking these things
		-perhaps initialize any used vectors with space up front, so
		vectors won't resize as often
		-find a way to avoid using getIndex(), since it's slow
			-perhaps have each PGVertex know its index
		-some of the data assignments in my A* implementation may be
		unnecessary, since I end up assigning to the vertex's data when
		it's resolved anyway. More specifically, I don't think there's any
		reason to update the data of the *not yet resolved* neighbors.
		-etc. (look for some things)
-speed up my A* algorithm application
	-think of things

-properly pick the next tasks from the below (including the "Eventually"
section)
-use OOP/inheritance better; Hunter.hpp and Player.hpp have duplication;
Entity could have mSprite and getLength(), perhaps
-somewhere, enforce that an enemy can't be bigger than a tile
-use Visual Studio project filters and folder organization
to make the project more organized
	-e.g. folder for Enemies, because it took me a while to see that Hunters
	had currently been the only enemy
-deal with compiler warnings

-set up good tile map for World?
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-walls (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and wall
		-player and enemy
		-player and coin
	-to prevent anyone going through walls:
		-steps in World.update():
			-set velocities of each entity
			-resolve collisions
				-for an entity that collides with a wall
					-if a component of velocity would cause the entity
					to go through the wall, make that component zero
			-apply velocities (i.e. move the entities)
-victory
-game over
-multiple levels

Eventually:
-----------

-put for-each loop in World::draw()
-why is the TextureHolder passed to the World class?
-remove unused/stub files; e.g.:
	-DrawableTile
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins
-tiles of different terrains
	-in pathfinding graph, apply the costs to the vertices
-test the readme steps for running project/tests
-see if Visual Studio can check for memory leaks
-if collision detection is too slow:
	-join together tiles of similar types to create bigger (rectangular)
	hitboxes:
		-somewhere, enforce that a tileset must be rectangular
			-how to make adding to a TileSet easier?
				-have a "capture" method that checks for rectangular-ness
				after adding all the captured tiles
		-somewhere, enforce that a tile can only be in one set (so walls
		can't be on top of each other)?
		-Wall class (that inherits from TileSet)
-where information on size is known, turn some vectors into arrays
-eliminate unneeded inclusions of <iostream>
-drop all Git stashes

Considerable:
-------------

-tile map creator
-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid walls
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system
-on background scolling:
	-instead, make the background switch between scrolling left, up, right,
	and down (based on how far it scrolls out) rather than following player
-edit the tests to separate the setup out of the cases, for reusability

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square