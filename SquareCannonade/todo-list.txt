Current:
--------

-getting A* to work (passing the tests)
	-finish implement performAStarSearch()
		-apply priority queue (so that selection of lowest f value is in
		O(1) time)
			-change name of mUnresolvedVertices, because this is NOT
			the set of ALL vertices that are unresolved; say mVerticesToClose
			-apply
		-what should I initially be setting the start vertices' estimated
		movement costs to?; document this somewhere so I stop wondering
		-apply heuristic (to make at least one more test pass, or else
		I should add a test; all tests should pass after this)
			-edit calculation of neighbor's estimated movement cost
	-actually call cleanUpAStarSearch() instead of just implementing it and
	not calling it like a silly person!! :-)
	-any more tests?
		-should I test for the case of the start and finish squares
		being the same?
	-speed up algorithm
		-find some way to measure the speed of the algorithm
		-things to speed up:
			-determination of the index to return when the goal vertex is reached
				-instead of storing pointers to the vertices in those four
				vectors, store their indices
					-would have to adjust the tests, which should be easy
			-checking if a neighbor is in the closed or open sets
				-change the sets into arrays that have the vertices' indices
				as array indices (reduces checking speed to O(1))
				-remove the two for loops checking these things
			-determination of which edge cost (10 or 14) to use
			(i.e. determination of whether the neighbor is diagonal or not)
				-remote the two for loops checking these things
			-perhaps initialize any used vectors with space up front, so
			vectors won't resize
			-etc. (look for some things)
	-clean up the A* code; stepwise refinement

-somewhere, enforce that an enemy can't be bigger than a tile
-perhaps try to apply Boost where appropriate, for the practice;
don't force it too much, though
-implementing A*: apply to game
	-perhaps store tile grid in PathfindingGraph instance
	-figure out heuristic function
		-ideas:
			-pure distance (i.e. Pythagorean theorem)
			-perhaps horizontal distance (to avoid temporal
			cost in using Pythagoren theorem)
	-CONCERN: make sure enemy doesn't keep going back and forth across the
	tile it's supposed to be headed to, due to the game's not knowing the
	enemy officially "reached" the tile (may need some epsilon value)
	-CONCERN: make sure enemy doesn't freeze if too close to player
	while in its grid square:
		-if enemy and player are in same grid square, set
		the enemy after the player's position (i.e. apply
		waypoint-based AI)
	-don't run A* each frame; maybe do each half second

-set up good tile map for World?
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-walls (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and wall
		-player and enemy
		-player and coin
	-to prevent anyone going through walls:
		-steps in World.update():
			-set velocities of each entity
			-resolve collisions
				-for an entity that collides with a wall
					-if a component of velocity would cause the entity
					to go through the wall, make that component zero
			-apply velocities (i.e. move the entities)
-victory
-game over
-multiple levels

Eventually:
-----------

-put for-each loop in World::draw()
-why is the TextureHolder passed to the World class?
-remove unused/stub files; e.g.:
	-DrawableTile
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins
-tiles of different terrains
	-in pathfinding graph, apply the costs to the vertices
-test the readme steps for running project/tests
-see if Visual Studio can check for memory leaks
-if collision detection is too slow:
	-join together tiles of similar types to create bigger (rectangular)
	hitboxes:
		-somewhere, enforce that a tileset must be rectangular
			-how to make adding to a TileSet easier?
				-have a "capture" method that checks for rectangular-ness
				after adding all the captured tiles
		-somewhere, enforce that a tile can only be in one set (so walls
		can't be on top of each other)?
		-Wall class (that inherits from TileSet)
-where information on size is known, turn some vectors into arrays
-eliminate unneeded inclusions of <iostream>

Considerable:
-------------

-tile map creator
-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid walls
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system
-on background scolling:
	-instead, make the background switch between scrolling left, up, right,
	and down (based on how far it scrolls out) rather than following player
-edit the tests to separate the setup out of the cases, for reusability

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square