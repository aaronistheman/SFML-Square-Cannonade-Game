Current:
--------

-applying A* to game
	-GOAL #1: without walls, the enemy should head to the player, as if it
	had waypoint-based AI
		-naive approach (good for a first approach): for each enemy, generate
		his path, then set his waypoint to target the first point of the path
		(or second, if the enemy is close enough to the first) (or can just
		set the enemy to the second point for this first approach)
		-NOTES/QUESTIONS:
			-the tile grid instance for the PathfindingGraph must be kept alive
			-make sure enemy doesn't keep going back and forth across the
			tile it's supposed to be headed to, due to the game's not knowing the
			enemy officially "reached" the tile (may need some epsilon value)
			-make sure enemy doesn't freeze if too close to player
			while in its grid square:
				-if enemy and player are in same grid square, set
				the enemy after the player's position (i.e. apply
				waypoint-based AI)
			-don't run A* each frame; maybe do each half second
			-what to do with the generated path?
	-GOAL #2: *with* walls, the enemy should head to the player, avoiding
	the walls in the way
		-implement walls and collision detection
		-AT THIS POINT: enemies should just get stuck on the walls
		-add the walls to the tile grid passed to the PathfindingGraph instance
-is the fact that I update the waypoints explicitly in World::update()
a bad thing?
-speed up graph creation
	-find some way to measure the speed of the graph creation
-speed up my A* algorithm implementation
	-find some way to measure the speed of the algorithm
	-things to speed up:
		-determination of the index to return when the goal vertex is reached
			-instead of storing pointers to the vertices in those four
			vectors, store their indices
				-would have to adjust the tests, which should be easy
		-checking if a neighbor is in the closed or open sets
			-change the sets into arrays that have the vertices' indices
			as array indices (reduces checking speed to O(1))
			-remove the two for loops checking these things
		-determination of which edge cost (10 or 14) to use
		(i.e. determination of whether the neighbor is diagonal or not)
			-remote the two for loops checking these things
		-perhaps initialize any used vectors with space up front, so
		vectors won't resize as often
		-find a way to avoid using getIndex(), since it's slow
			-perhaps have each PGVertex know its index
		-some of the data assignments in my A* implementation may be
		unnecessary, since I end up assigning to the vertex's data when
		it's resolved anyway. More specifically, I don't think there's any
		reason to update the data of the *not yet resolved* neighbors.
		-etc. (look for some things)
-speed up my A* algorithm application
	-think of things

-somewhere, enforce that an enemy can't be bigger than a tile
-use Visual Studio project filters and folder organization
to make the project more organized
	-e.g. folder for Enemies, because it took me a while to see that Hunters
	had currently been the only enemy
-deal with compiler warnings

-set up good tile map for World?
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-walls (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and wall
		-player and enemy
		-player and coin
	-to prevent anyone going through walls:
		-steps in World.update():
			-set velocities of each entity
			-resolve collisions
				-for an entity that collides with a wall
					-if a component of velocity would cause the entity
					to go through the wall, make that component zero
			-apply velocities (i.e. move the entities)
-victory
-game over
-multiple levels

Eventually:
-----------

-put for-each loop in World::draw()
-why is the TextureHolder passed to the World class?
-remove unused/stub files; e.g.:
	-DrawableTile
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins
-tiles of different terrains
	-in pathfinding graph, apply the costs to the vertices
-test the readme steps for running project/tests
-see if Visual Studio can check for memory leaks
-if collision detection is too slow:
	-join together tiles of similar types to create bigger (rectangular)
	hitboxes:
		-somewhere, enforce that a tileset must be rectangular
			-how to make adding to a TileSet easier?
				-have a "capture" method that checks for rectangular-ness
				after adding all the captured tiles
		-somewhere, enforce that a tile can only be in one set (so walls
		can't be on top of each other)?
		-Wall class (that inherits from TileSet)
-where information on size is known, turn some vectors into arrays
-eliminate unneeded inclusions of <iostream>
-drop all Git stashes

Considerable:
-------------

-tile map creator
-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid walls
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system
-on background scolling:
	-instead, make the background switch between scrolling left, up, right,
	and down (based on how far it scrolls out) rather than following player
-edit the tests to separate the setup out of the cases, for reusability

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square