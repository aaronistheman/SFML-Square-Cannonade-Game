Current:
--------

-background (below the platform): texture repeating/scrolling
	-add (static) background (e.g. clouds)
		-repeating texture?
	-make background scroll
	-why is the TextureHolder passed to the World class?
-(not necessarily complete) basic classes for Cannon, EnemySquare, etc.
	-put the getTransform() logic in one place
-data read from text files
	-import DataTables' file reader code from my Tanks game
-switch resource ids so they use C++11 enums
-holes (should be own type); represent as square(s)
-dummy (placeholder, perhaps immobile) enemies
-collision detection
	-probably use unit tests here
	-types:
		-player and hole
		-player and enemy
		-player and coin
-victory
-game over
-multiple levels
-use A* pathfinding algorithm to have enemies avoid holes as
they navigate to the player
	-this logic should be in update() method (or submethod)
		-don't run A* each frame; maybe do each half second
	-figure out heuristic function
	-ideas on how:
		-see memo in my phone

Eventually:
-----------

-remove unused/stub files
-look into C++ Boost library
-spritesheets
-multiplayer mode with SFML's (TCP?) sockets
	-2 player mode in which both players collect coins

Considerable:
-------------

-why does State store a pointer--not a reference--to the window?
-could only render squares within a certain distance of any entity,
then make the rest dark, so the player would have to be careful to
avoid holes
-state management
	-remove that boolean check for keepState in Application::processInput()
	-import StateStack classes from "SFML Game Development" book
-enemies with multiple hitboxes, just for the challenge
-grid system for collision detection (not just for pathfinding)
	-could also restrict movement to obeying this grid system

OOP Classes (incomplete):
------------------------
ResourceHandler
Application/Game
Entity
	Coin
	Cannon
	Square